########### IMPORTANT ########## IMPORTANT ########### IMPORTANT ###########
#                                                                          #
# Whenever you change Exim's configuration file, you *must* remember to    #
# HUP the Exim daemon, because it will not pick up the new configuration   #
# until you do. However, any other Exim processes that are started, for    #
# example, a process started by an MUA in order to send a message, will    #
# see the new configuration as soon as it is in place.                     #
#                                                                          #
# You do not need to HUP the daemon for changes in auxiliary files that    #
# are referenced from this file. They are read every time they are used.   #
#                                                                          #
# It is usually a good idea to test a new configuration for syntactic      #
# correctness before installing it (for example, by running the command    #
# "exim -C /config/file.new -bV").                                         #
#                                                                          #
# This configuration contains just the needed parameters to run ELMA,      #
# with short or even none comments.                                        #
# For a full and comprehensive documentation of all available parameters,  #
# see http://www.exim.org/exim-html-current/doc/html/spec_html/index.html  #
#                                                                          #
# vim folding: use zo to open, zc to close a folding                       #
#                                                                          #
########### IMPORTANT ########## IMPORTANT ########### IMPORTANT ###########


######################################################################
#                    MAIN CONFIGURATION SETTINGS                     #
######################################################################

# LDAP connection parameters <<<
LDAP_HOSTNAME = 127.0.0.1:389
LDAP_BASEDN = o=mybasedn
LDAP_DOMAINS_ROOT_DN = ou=domains,LDAP_BASEDN
LDAP_USERS_ROOT_DN = ou=users,LDAP_BASEDN
LDAP_USER = uid=exim4,LDAP_USERS_ROOT_DN
LDAP_PASS = exim4pass
LDAP_DEFAULT_SERVERS = 127.0.0.1::389
# >>>

# LDAP macros# <<<
# Check if a domain is active
LDAP_ACTIVE_DOMAIN = ${\
  if eqi {true}{\
    ${lookup ldap{user=LDAP_USER pass=LDAP_PASS \
      ldap://LDAP_HOSTNAME/dc=${quote_ldap_dn:${domain}},LDAP_DOMAINS_ROOT_DN?mailStatus?sub\
    }}\
  } {yes}{no}\
}

# Check if an users account is active
LDAP_ACTIVE_USER = ${\
  if eqi {true}{\
    ${lookup ldap{user=LDAP_USER pass=LDAP_PASS \
      ldap://LDAP_HOSTNAME/uid=${quote_ldap_dn:${local_part}},dc=${quote_ldap_dn:${domain}},LDAP_DOMAINS_ROOT_DN?mailStatus?sub\
    }}\
  } {yes}{no}\
}

# get the uid attribute for an user
LDAP_GET_UID = ${lookup ldap{\
  user=LDAP_USER pass=LDAP_PASS \
  ldap://LDAP_HOSTNAME/uid=${quote_ldap_dn:${local_part}},dc=${quote_ldap_dn:${domain}},LDAP_DOMAINS_ROOT_DN?uid?sub?(objectclass=mailUser)\
} {$value} {no} }

# get the mailSieveFilter attribute for an user
LDAP_GET_USER_FILTER = ${lookup ldap{\
  user=LDAP_USER pass=LDAP_PASS \
  ldap://LDAP_HOSTNAME/uid=${quote_ldap_dn:${local_part}},dc=${quote_ldap_dn:${domain}},LDAP_DOMAINS_ROOT_DN?mailSieveFilter?sub?(objectclass=mailUser)\
} {$value} }

# get the mailSieveFilter attribute for a domain
LDAP_GET_DOMAIN_FILTER = ${lookup ldap{\
  user=LDAP_USER pass=LDAP_PASS \
  ldap://LDAP_HOSTNAME/dc=${quote_ldap_dn:${domain}},LDAP_DOMAINS_ROOT_DN?mailSieveFilter?sub?(objectclass=mailDomain)\
} {$value} }

# return the user's homeDirectory
LDAP_HOME_DIRECTORY = ${lookup ldap {\
  user=LDAP_USER pass=LDAP_PASS \
  ldap://LDAP_HOSTNAME/uid=${quote_ldap_dn:${local_part}},dc=${quote_ldap_dn:${domain}},LDAP_DOMAINS_ROOT_DN?homeDirectory?\
} {$value} fail}

# TODO: comment
LDAP_ALIASES = ${\
  if eq {yes}{LDAP_ACTIVE_USER} {\
    ${lookup ldapm{\
      user=LDAP_USER pass=LDAP_PASS \
      ldap://LDAP_HOSTNAME/uid=${quote_ldap_dn:${local_part}},dc=${quote_ldap_dn:${domain}},LDAP_DOMAINS_ROOT_DN?mailaliasedname?sub?(objectclass=mailalias)\
    }}\
  } {} \
}
# >>>

# the rest <<<
# Most times the result of uname() is sufficient. If not, 
# specifiy your hostname here
#primary_hostname =

# We fetch our local_domains from LDAP.
domainlist local_domains = @ : ${tr {${lookup ldapm{user=LDAP_USER pass=LDAP_PASS ldap://LDAP_HOSTNAME/LDAP_DOMAINS_ROOT_DN?dc?one?(mailStatus=TRUE)}}} {\n}{:}}

# localhost is allowed to relay - noone else
hostlist   relay_from_hosts = 127.0.0.1

# Exim will connect SpamAssassin per default on localhost:783.
#spamd_address = 127.0.0.1 783

# Allow any client to use TLS.
#tls_advertise_hosts = *

# TODO: specify your certificate/key here!
#tls_certificate = /etc/ssl/exim.crt
#tls_privatekey = /etc/ssl/exim.pem

# Add port 465 to daemon_smtp_ports, if you want to provide tls-on-connect
daemon_smtp_ports = 25 : 587
#tls_on_connect_ports = 465

# Qualify locally generated sender-addresses, 
# per default with our primary_hostname
sender_unqualified_hosts = localhost

# No deliveries will ever be run under the uids of these users
never_users = root

# Every host will get a lookup for free
host_lookup = *

# .. but we won't do any ident-lookups
rfc1413_hosts = *
rfc1413_query_timeout = 0s

# This option unfreezes frozen bounce messages after two days, tries
# once more to deliver them, and ignores any delivery failures.
ignore_bounce_errors_after = 2d

# This option cancels (removes) frozen messages that are older than a week.
timeout_frozen_after = 7d
# >>>

######################################################################
#                       ACL CONFIGURATION                            #
#         Specifies access control lists for incoming SMTP mail      #
######################################################################

# ACL assignment <<<
acl_smtp_rcpt = acl_check_rcpt
acl_smtp_data = acl_check_data
# >>>

begin acl

# RCPT TO <<<
acl_check_rcpt:

  # Accept if the source is local SMTP
  accept  hosts = :

  # The following section of the ACL is concerned with local parts that contain
  # @ or % or ! or / or | or dots in unusual places.
  deny    message       = Restricted characters in address
          domains       = +local_domains
          local_parts   = ^[.] : ^.*[@%!/|]

  deny    message       = Restricted characters in address
          domains       = !+local_domains
          local_parts   = ^[./|] : ^.*[@%!] : ^.*/\\.\\./

  # Accept mail to postmaster in any local domain, regardless of the source,
  # and without verifying the sender.
  accept  local_parts   = postmaster
          domains       = +local_domains

  # Deny unless the sender address can be verified.
  require verify        = sender

  # Accept if the message comes from one of the hosts for which we are an
  # outgoing relay.
  accept  hosts         = +relay_from_hosts
          control       = submission

  # Accept if the message arrived over an authenticated connection.
  accept  authenticated = *
          control       = submission

  # Insist that any other recipient address that we accept is either in one of
  # our local domains, or is in a domain for which we explicitly allow
  # relaying. Any other domain is rejected as being unacceptable for relaying.
  require message = relay not permitted
          domains = +local_domains : +relay_domains

  # We also require all accepted addresses to be verifiable.
  require verify = recipient

  # At this point, the address has passed all the checks that have been
  # configured, so we accept it unconditionally.
  accept

# >>>

# DATA <<<
acl_check_data:

  # Deny if the message contains a virus. Before enabling this check, you
  # must install a virus scanner and set the av_scanner option above.
  #deny    malware    = *
  #        message    = This message contains a virus ($malware_name).

  # Add headers to a message if it is judged to be spam. Before enabling this,
  # you must install SpamAssassin. You may also need to set the spamd_address
  # option above.
  #warn    spam       = nobody
  #        add_header = X-Spam_score: $spam_score\n\
  #                     X-Spam_score_int: $spam_score_int\n\
  #                     X-Spam_bar: $spam_bar\n\
  #                     X-Spam_report: $spam_report

  # Accept the message.
  accept

# >>>

######################################################################
#                      ROUTERS CONFIGURATION                         #
#               Specifies how addresses are handled                  #
######################################################################

begin routers

# mails destined for remote hosts <<<
dnslookup:
  driver = dnslookup
  domains = ! +local_domains
  transport = remote_smtp
  ignore_target_hosts = 0.0.0.0 : 127.0.0.0/8
  no_more
# >>>

# system_aliases <<<
system_aliases:
  driver = redirect
  allow_fail
  allow_defer
  data = ${lookup{$local_part}lsearch{/etc/aliases}}
# user = exim
  file_transport = address_file
  pipe_transport = address_pipe
# >>>

# resolve aliases from LDAP <<<
ldap_aliases:
  driver = redirect
  allow_fail
  allow_defer
  data = LDAP_ALIASES 
# >>>

# ldap domain filter <<<
ldap_domain_filter:
  driver = redirect
  allow_filter
  user = mail
  data = ${if eq {yes} {LDAP_ACTIVE_DOMAIN} {LDAP_GET_DOMAIN_FILTER}}
  router_home_directory = LDAP_HOME_DIRECTORY
  file_transport = local_delivery
# >>>

# ldap user filter <<<
ldap_user_filter:
  driver = redirect
  allow_filter
  user = mail
  data = ${if eq {yes} {LDAP_ACTIVE_USER} {LDAP_GET_USER_FILTER}}
  router_home_directory = LDAP_HOME_DIRECTORY
  file_transport = local_delivery
# >>>

# deliver to local user <<<
ldap_user:
  driver = accept
  condition = ${if eq {yes} {LDAP_ACTIVE_USER} {LDAP_GET_UID}}
  router_home_directory = LDAP_HOME_DIRECTORY
  transport = local_delivery
  cannot_route_message = Unknown user
# >>>

######################################################################
#                      TRANSPORTS CONFIGURATION                      #
######################################################################

begin transports

# This transport is used for delivering messages over SMTP connections <<<
remote_smtp:
  driver = smtp
# >>>

# Local delivery to maildir <<<
local_delivery:
  driver = appendfile
  mode_fail_narrower = false
  maildir_format
  delivery_date_add
  envelope_to_add
  return_path_add
  group = mail
  mode = 0660
# >>>

# This transport is used for handling autoreplies generated by the filtering <<<
# option of the userforward router.
address_reply:
  driver = autoreply
# >>>

######################################################################
#                      RETRY CONFIGURATION                           #
######################################################################

begin retry

# This single retry rule applies to all domains and all errors. It specifies <<<
# retries every 15 minutes for 2 hours, then increasing retry intervals,
# starting at 1 hour and increasing each time by a factor of 1.5, up to 16
# hours, then retries every 6 hours until 4 days have passed since the first
# failed delivery.

# Address or Domain    Error       Retries
# -----------------    -----       -------

*                      *           F,2h,15m; G,16h,1h,1.5; F,4d,6h
# >>>

######################################################################
#                      REWRITE CONFIGURATION                         #
######################################################################

begin rewrite

######################################################################
#                   AUTHENTICATION CONFIGURATION                     #
######################################################################

begin authenticators

# PLAIN authenticator <<<
plain:
  driver = plaintext
  public_name = PLAIN
  server_prompts = :
  server_condition = ${if ldapauth {user="uid=${quote_ldap_dn:${extract{1}{@}{$2}}},dc=${quote_ldap_dn:${extract{2}{@}{$2}}},LDAP_DOMAINS_ROOT_DN" pass=${quote_ldap_dn::$3} ldap://LDAP_HOSTNAME/}{yes}{no}}
  server_set_id = $2
# >>>

# LOGIN <<<
login:
  driver = plaintext
  public_name = LOGIN
  server_prompts = Username:: : Password::
  server_condition = ${if ldapauth {user="uid=${quote_ldap_dn:${extract{1}{@}{$1}}},dc=${quote_ldap_dn:${extract{2}{@}{$1}}},LDAP_DOMAINS_ROOT_DN" pass=${quote_ldap_dn:$2} ldap://LDAP_HOSTNAME/}{yes}{no}}
  server_set_id = $1
# >>>

# CRAM-MD5 <<<
cram:
  driver = cram_md5
  public_name = CRAM-MD5
  server_secret = ${lookup ldapm{user=LDAP_USER pass=LDAP_PASS ldap://LDAP_HOSTNAME/uid=${quote_ldap_dn:${extract{1}{@}{$1}}},dc=${quote_ldap_dn:${extract{2}{@}{$1}}},LDAP_DOMAINS_ROOT_DN?clearPassword?sub}{$value}fail}
  server_set_id = $1
# >>>

# vim:foldmethod=marker:foldmarker=<<<,>>>
